cat > Jenkinsfile << 'EOF'
pipeline {
    agent {
        label "kubernetes-agent"
    }

    environment {
        // Branch to Environment Mapping
        ENV_CONFIG = [
            'develop': [
                name: 'dev',
                AWS_ACCOUNT: '111111111111',  // ✅ FIXED: Changed to uppercase
                cluster: 'eks-dev',
                ecr_url: '111111111111.dkr.ecr.us-east-1.amazonaws.com',
                kubeconfig: 'kubeconfig-dev',
                aws_creds: 'aws-dev',
                helm_timeout: '10m',
                replicas: '2'
            ],
            'release': [
                name: 'stage', 
                AWS_ACCOUNT: '222222222222',  // ✅ FIXED: Changed to uppercase
                cluster: 'eks-stage',
                ecr_url: '222222222222.dkr.ecr.us-east-1.amazonaws.com',
                kubeconfig: 'kubeconfig-stage',
                aws_creds: 'aws-stage',
                helm_timeout: '15m',
                replicas: '3'
            ],
            'main': [
                name: 'prod',
                AWS_ACCOUNT: '333333333333',  // ✅ FIXED: Changed to uppercase
                cluster: 'eks-prod',
                ecr_url: '333333333333.dkr.ecr.us-east-1.amazonaws.com',
                kubeconfig: 'kubeconfig-prod',
                aws_creds: 'aws-prod',
                helm_timeout: '20m',
                replicas: '4'
            ]
        ]

        // Current environment config
        CONFIG = ENV_CONFIG[env.BRANCH_NAME]
        ENV_NAME = CONFIG.name
        AWS_ACCOUNT = CONFIG.AWS_ACCOUNT  // ✅ FIXED: Now matches case
        ECR_URL = CONFIG.ecr_url
        KUBECONFIG_ID = CONFIG.kubeconfig
        AWS_CREDS_ID = CONFIG.aws_creds
        HELM_TIMEOUT = CONFIG.helm_timeout
        REPLICA_COUNT = CONFIG.replicas

        // Application config
        APP_NAME = "user-service"
        DOCKER_IMAGE_TAG = "${ENV_NAME}-${env.BUILD_NUMBER}-${env.GIT_COMMIT.take(8)}"
        HELM_RELEASE = "${APP_NAME}"
        HELM_CHART_PATH = "./helm"
    }

    stages {
        stage('Assume Role & Deploy') {
            steps {
                script {
                    sh """
                        # ✅ NOW VARIABLE CASE MATCHES
                        aws sts assume-role \
                            --role-arn arn:aws:iam::${AWS_ACCOUNT}:role/Jenkins-Deploy-Role \
                            --role-session-name jenkins-${APP_NAME}-${ENV_NAME} > /tmp/assume-role-output.json
                            
                        export AWS_ACCESS_KEY_ID=\$(jq -r '.Credentials.AccessKeyId' /tmp/assume-role-output.json)
                        export AWS_SECRET_ACCESS_KEY=\$(jq -r '.Credentials.SecretAccessKey' /tmp/assume-role-output.json)
                        export AWS_SESSION_TOKEN=\$(jq -r '.Credentials.SessionToken' /tmp/assume-role-output.json)

                        # Deploy with Helm
                        helm upgrade --install ${HELM_RELEASE} ${HELM_CHART_PATH} \
                            --set image.repository=${ECR_URL}/${APP_NAME} \
                            --set image.tag=${DOCKER_IMAGE_TAG} \
                            --wait \
                            --timeout ${HELM_TIMEOUT} \
                            --atomic
                    """
                }
            }
        }
    }
}
EOF
